// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "basic_types.h"
#include "randomized_svd_error.h"
#include "disable_dlib_warnings.h"
RLIBV_DISABLE_DLIB_WARNINGS
#include <dlib/matrix.h>
RLIBV_RENABLE_WARNINGS
#include <vector>
#include <iostream>

namespace rlibv
{
	/**
   	* \defgroup Learning Machine learning
   	* @{
   	*/

	using dlib::serialize;
	using dlib::deserialize;

	/**
	 * @brief A class representing a Principal Component Analysis Model of fixed input and output size
	 * @tparam T T must be either float or double
	 * @tparam M the length of the original data vectors to be transformed by the model.
	 * @tparam N the number of parameters in the model - i.e. the length of the output vectors
	 *           generated by the model (the number of eigenvectors)
	 */

	template<typename T, int M, int N>
	class fixed_pca_model
	{
		static_assert(
			std::is_same<T, float>::value ||
			std::is_same<T, double>::value,
			"T must be a float or double type");
		static_assert(M >= 2, "M must be >=2");
		static_assert(N >= 1, "N must be >=1");
	public:
		/**
		 * @brief Train model retaining N eigenvectors
		 * @details The trainer uses the fast randomized svd method.
		 * @param data The training data as a std::vector of dlib column vectors
		 * @pre data.size() > N
		 * @throws randomized_svd_error if the SVD falls over (e.g. all vectors equal)
		 * @throws std::runtime error for all other failure conditions
		 */
		void train(const std::vector<dlib::matrix<T, M, 1>>& data);

		/**
		 * @brief Return the best set of parameters for the given data.
		 * @param data_as_col the input data vector
		 * @return A column vector which is the PCA parametrization of the input data.
		 */
		dlib::matrix<T, N, 1> parameterize(const dlib::matrix<T, M, 1>& data_as_col) const;

		/**
		 * Confirms whether the model is trained.
		 * 
		 * \return true iff trained.
		 */
		bool is_trained() const;

		/**
		 * @brief Serialization
		 * @tparam U must be either float or double
		 * @param item The fixed PCA model
		 * @tparam P the length of the original data vectors to be transformed by the model.
		 * @tparam Q the number of parameters in the model - i.e. the length of the output vectors
		 *           generated by the model (the number of eigenvectors)
		 * @param out The output stream
		 */
		template<typename U, int P, int Q>
		friend void serialize(const fixed_pca_model<U, P, Q>& item, std::ostream& out);

		/**
		 * @brief Deserialization
		 * @tparam U must be either float or double
		 * @param item The resulting fixed PCA model
		 * @tparam P the length of the original data vectors to be transformed by the model.
		 * @tparam Q the number of parameters in the model - i.e. the length of the output vectors
		 *           generated by the model (the number of eigenvectors)
		 * @param in The input stream
		 */
		template<typename U, int P, int Q>
		friend void deserialize(fixed_pca_model<U, P, Q>& item, std::istream& in);
	

	private:
		bool is_trained_ = false;
		dlib::matrix<T, M, N> eigenvectors_;
		dlib::matrix<T, 1, N> eigenvalues_;
		dlib::matrix<T, 1, N> sqrt_eigenvalues_;
		dlib::matrix<T, 1, M> mean_;
		dlib::matrix<T, N, 1> parameter_mid_values_;
		dlib::matrix<T, N, 1> parameter_ranges_;

	};


	template<typename U, int P, int Q>
	void serialize(const fixed_pca_model<U, P, Q>& item, std::ostream& out);


	template<typename U, int P, int Q>
	void deserialize(fixed_pca_model<U, P, Q>& item, std::istream& in);

	/**@}*/
}

#include "impl/fixed_pca_model.hpp"
